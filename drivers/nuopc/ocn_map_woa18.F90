module ocn_map_woa

   use ESMF              , only : ESMF_Mesh, ESMF_MeshCreate, ESMF_FILEFORMAT_ESMFMESH
   use ESMF              , only : ESMF_Field, ESMF_FieldCreate
   use ESMF              , only : ESMF_FieldBundle, ESMF_FieldBundleCreate
   use ESMF              , only : ESMF_FieldBundleAdd, ESMF_FieldBundleGet
   use ESMF              , only : ESMF_SUCCESS, ESMF_LogFoundError
   use ESMF              , only : ESMF_MESHLOC_ELEMENT, ESMF_TYPEKIND_R8
   use nuopc_shr_methods , only : chkerr
   use shr_kind_mod      , only : r8 => shr_kind_r8, CL => shr_kind_cl, CS => shr_kind_cs
   use shr_log_mod       , only : errMsg => shr_log_errMsg
   use mod_io_input      , only : read_map_input_data, field_getfldptr
   use mod_io_output     , only : io_write
   use pio               , only : file_desc_t, iosystem_desc_t
   use pio               , only : pio_get_iosys, pio_get_iotype, pio_getioformat
   use pio               , only : pio_openfile, pio_closefile
   use pio               , only : iosystem_desc_t, file_desc_t
   use mod_xc

   implicit none
   private

   public :: map_woa

   ! TODO: map first order conservative rather than bilinear
   ! also - use the fill value as a public
   ! Do not call this upon restart
   ! mod_inicon not called when reading a restart file (logic set in mod_blom_init)
   ! remove the call from HAMOCC ifdef
   ! do not use wao18 = use woa

   real(r8), public, allocatable :: t_woa(:,:,:)
   real(r8), public, allocatable :: s_woa(:,:,:)
   real(r8), public, allocatable :: depth_woa(:)
   real(r8), public, allocatable :: depth_bnds_woa(:,:)

   character(len=*), parameter :: u_FILE_u = &
      __FILE__

!===============================================================================
contains
!===============================================================================

   subroutine map_woa(mesh_blom, rc)

      ! input/out variables
      type(ESMF_Mesh)     , intent(in)  :: mesh_blom
      integer             , intent(out) :: rc

      ! local variables:
      character(len=CL)      :: mesh_input_file
      character(len=CL)      :: filename_t
      character(len=CL)      :: filename_s
      character(len=4)       :: fldlist_input_t(1)
      character(len=4)       :: fldlist_input_s(1)
      type(ESMF_Mesh)        :: mesh_input
      type(ESMF_Field)       :: field_blom
      type(ESMF_FieldBundle) :: fldbun_blom
      integer                :: nlev
      integer                :: nf,n,i,j,ko,l
      integer                :: jjcpl
      real(r8), pointer      :: dataptr2d(:,:)
      type(file_desc_t)      :: pioid
      integer                :: dimid
      integer                :: io_type                         ! pio info
      integer                :: io_format                       ! pio info
      type(iosystem_desc_t), pointer :: pio_subsystem => null() ! pio info
      !-------------------------------------------------------------------------------

      rc = ESMF_SUCCESS

      ! ---------------------------
      ! Filenames and field names (TODO: this should be moved to namelist)
      ! ---------------------------

      mesh_input_file = '/cluster/projects/nn9560k/matsbn/WOA_mesh/WOA_1.00_degree_ESMFmesh_20250506_cdf5.nc'
      filename_t = '/cluster/work/users/matsbn/WOA18/woa18_decav_t13_01.nc'
      fldlist_input_t(1) = 't_an'
      filename_s = '/cluster/work/users/matsbn/WOA18/woa18_decav_s13_01.nc'
      fldlist_input_s(1) = 's_an'

      ! ---------------------------
      ! Determine vertical dimension
      ! ---------------------------

      pio_subsystem => shr_pio_getiosys('OCN')
      io_type       =  shr_pio_getiotype('OCN')
      io_format     =  shr_pio_getioformat('OCN')
      if (mnproc == 1) then
         write(lp,'(a)') 'determining vertical dimension of WOA climatology from '//trim(filename_t)
      end if
      rcode = pio_openfile(pio_subsystem, pioid, io_type, trim(filename_t), pio_nowrite)
      rcode = pio_inq_dimid(pioid, 'depth', dimid)
      rcode = pio_inq_dimlen(pioid, dimid, nlev)
      call pio_closefile(pioid)

      ! ---------------------------
      ! Allocate module arrays
      ! ---------------------------

      allocate(t_woa(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,nlev), &
               s_woa(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,nlev), &
               depth_woa(nlev), &
               depth_bnds_woa(2,nlev), &
               stat = rocde)
      if (rcode /= 0) then
         write(lp,*) 'Failed to allocate WOA arrays!'
         call xchalt('(ocn_map_woa)')
         stop '(ocn_map_woa)'
      endif

      allocate(woa18_t_depth(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,nlev))
      allocate(woa18_s_depth(1-nbdy:idm+nbdy,1-nbdy:jdm+nbdy,nlev))
      allocate(depth_bnds(2,nlev))
      allocate(depth(nlev))

      ! ---------------------------
      ! Create input data mesh
      ! ---------------------------
      mesh_input = ESMF_MeshCreate(filename=trim(mesh_input_file), fileformat=ESMF_FILEFORMAT_ESMFMESH, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! ---------------------------
      ! Create a field bundle on the blom mesh
      ! ---------------------------

      fldbun_blom = ESMF_FieldBundleCreate(name='fldbun_blom', rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return
      field_blom = ESMF_FieldCreate(mesh_blom, ESMF_TYPEKIND_R8, meshloc=ESMF_MESHLOC_ELEMENT, name='field_blom',  &
           ungriddedLbound=(/1/), ungriddedUbound=(/nlev/), gridToFieldMap=(/2/), rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return
      call ESMF_FieldBundleAdd(fldbun_blom, (/field_blom/), rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! ---------------------------
      ! Read and map temperature - the output will be fldbun_blom which is on the blom mesh
      ! ---------------------------

      ! Read and map the data using bilinear interpolation - and also get depth_bnds and depths
      call read_map_input_data(mesh_input, filename_t, fldlist_input_t, nlev, 'bilinear', &
           fldbun_blom, depth=depth, depth_bnds=depth_bnds, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! Plot mapped fldbun temperature
      call io_write(filename="woa18_t_an.nc", fldbun=fldbun_blom, use_float=.false., rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! Extract the data from the field bundle
      call ESMF_FieldBundleGet(fldbun_blom, fieldName='field_blom', field=field_blom, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return
      call field_getfldptr(field_blom, fldptr2=dataptr2d, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! Set the j-extent of the local ocean domain to be exchanged. Needed
      ! because of duplication of the last global domain row when using a
      ! tripolar grid.
      if (nreg == 2 .and. nproc == jpr) then
         jjcpl = jj - 1
      else
         jjcpl = jj
      endif

      ! now set woa18_t_depth
      do j = 1, jjcpl
         do l = 1, isp(j)
            do i = max(1, ifp(j,l)), min(ii, ilp(j,l))
               n = (j - 1)*ii + i
               do ko = 1,nlev
                  woa18_t_depth(i,j,ko) = dataptr2d(ko,n)
               end do
            end do
         end do
      end do

      ! ---------------------------
      ! Read and map salinity - the output will again be in fldbun_blom on the blom mesh
      ! ---------------------------

      ! Read and map the data using bilinear interpolation
      call read_map_input_data(mesh_input, filename_s, fldlist_input_s, nlev, 'bilinear', &
           fldbun_blom, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! Extract the data from the field bundle
      call ESMF_FieldBundleGet(fldbun_blom, fieldName='field_blom', field=field_blom, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return
      call field_getfldptr(field_blom, fldptr2=dataptr2d, rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! Plot mapped fldbun salinity
      call io_write(filename="woa18_s_an.nc", fldbun=fldbun_blom, use_float=.false., rc=rc)
      if (chkerr(rc,__LINE__,u_FILE_u)) return

      ! now set woa18_s_depth
      do j = 1, jjcpl
         do l = 1, isp(j)
            do i = max(1, ifp(j,l)), min(ii, ilp(j,l))
               n = (j - 1)*ii + i
               do ko = 1,nlev
                  woa18_s_depth(i,j,ko) = dataptr2d(ko,n)
               end do
            end do
         end do
      end do

   end subroutine map_woa

end module ocn_map_woa
